/**
 * Agent 3: Database & Backend Developer (Improved)
 * 
 * รับผิดชอบ:
 * - สร้าง Supabase migrations จาก Agent 2 output
 * - สร้าง API routes จาก Agent 2 output
 * - สร้าง database functions และ triggers
 * - ตั้งค่า RLS policies
 */

import { createLogger } from '../utils/logger'
import type { Agent2Output } from './types'

const logger = createLogger({ component: 'Agent3' })

export interface Agent3Output {
  migrations: {
    filename: string
    sql: string
    description: string
  }[]
  api_routes: {
    path: string
    filename: string
    code: string
  }[]
  database_functions: {
    name: string
    sql: string
    description: string
  }[]
  rls_policies: {
    table: string
    policy_name: string
    sql: string
  }[]
  validation_schemas: {
    name: string
    schema: Record<string, any>
  }[]
}

/**
 * Execute Agent 3: Database & Backend Development
 */
export async function executeAgent3(
  architecture: Agent2Output
): Promise<Agent3Output> {
  logger.info('Starting Database & Backend Development')
  
  try {
    // 1. Generate database migrations from architecture
    const migrations = await generateMigrations(architecture)
    logger.info(`Generated ${migrations.length} migrations`)
    
    // 2. Generate API routes
    const apiRoutes = await generateAPIRoutes(architecture)
    logger.info(`Generated ${apiRoutes.length} API routes`)
    
    // 3. Generate database functions
    const databaseFunctions = await generateDatabaseFunctions(architecture)
    logger.info(`Generated ${databaseFunctions.length} database functions`)
    
    // 4. Generate RLS policies
    const rlsPolicies = await generateRLSPolicies(architecture)
    logger.info(`Generated ${rlsPolicies.length} RLS policies`)
    
    // 5. Generate validation schemas
    const validationSchemas = await generateValidationSchemas(architecture)
    logger.info(`Generated ${validationSchemas.length} validation schemas`)
    
    logger.info('Database & Backend Development completed successfully')
    
    return {
      migrations,
      api_routes: apiRoutes,
      database_functions: databaseFunctions,
      rls_policies: rlsPolicies,
      validation_schemas: validationSchemas
    }
  } catch (error) {
    logger.error('Agent 3 failed', error instanceof Error ? error : new Error(String(error)))
    throw new Error(`Agent 3 failed: ${error instanceof Error ? error.message : String(error)}`)
  }
}

/**
 * Generate database migrations from architecture
 */
async function generateMigrations(architecture: Agent2Output) {
  const migrations: Agent3Output['migrations'] = []
  
  const timestamp = Date.now()
  const migrationNumber = String(timestamp).slice(-3)
  
  // Extract tables from database_schema
  const tables = architecture.database_schema?.tables || []
  
  if (tables.length === 0) {
    logger.warn('No tables found in architecture')
    return migrations
  }
  
  // Generate CREATE TABLE statements
  let sql = `-- Migration: Create tables
-- Generated by Agent 3
-- Timestamp: ${new Date().toISOString()}

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

`
  
  // Generate table definitions
  for (const table of tables) {
    const tableName = typeof table === 'string' ? table : table.name
    
    sql += `-- Table: ${tableName}\n`
    sql += `CREATE TABLE IF NOT EXISTS ${tableName} (\n`
    
    // Default columns for all tables
    sql += `  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n`
    
    // Add custom columns if available
    if (typeof table === 'object' && table.columns) {
      for (const column of table.columns) {
        const nullable = column.nullable ? '' : ' NOT NULL'
        const defaultValue = column.default ? ` DEFAULT ${column.default}` : ''
        sql += `  ${column.name} ${column.type}${nullable}${defaultValue},\n`
      }
    }
    
    // Add standard audit columns
    sql += `  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n`
    sql += `  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n`
    sql += `);\n\n`
    
    // Add indexes
    sql += `-- Indexes for ${tableName}\n`
    sql += `CREATE INDEX IF NOT EXISTS ${tableName}_created_at_idx ON ${tableName}(created_at DESC);\n\n`
    
    // Add updated_at trigger
    sql += `-- Trigger for ${tableName}\n`
    sql += `CREATE TRIGGER update_${tableName}_updated_at\n`
    sql += `  BEFORE UPDATE ON ${tableName}\n`
    sql += `  FOR EACH ROW\n`
    sql += `  EXECUTE FUNCTION update_updated_at_column();\n\n`
  }
  
  // Enable RLS
  sql += `-- Enable Row Level Security\n`
  for (const table of tables) {
    const tableName = typeof table === 'string' ? table : table.name
    sql += `ALTER TABLE ${tableName} ENABLE ROW LEVEL SECURITY;\n`
  }
  
  migrations.push({
    filename: `${migrationNumber}_create_tables.sql`,
    sql,
    description: `Create ${tables.length} tables with RLS enabled`
  })
  
  return migrations
}

/**
 * Generate API routes from architecture
 */
async function generateAPIRoutes(architecture: Agent2Output) {
  const routes: Agent3Output['api_routes'] = []
  
  // Extract endpoints from architecture
  const endpoints = architecture.api_endpoints || []
  
  if (endpoints.length === 0) {
    logger.warn('No API endpoints found in architecture')
    return routes
  }
  
  // Group endpoints by resource
  const resourceMap = new Map<string, typeof endpoints>()
  
  for (const endpoint of endpoints) {
    const path = typeof endpoint === 'string' ? endpoint : endpoint.path
    const resource = path.split('/')[1] || 'default'
    
    if (!resourceMap.has(resource)) {
      resourceMap.set(resource, [])
    }
    resourceMap.get(resource)!.push(endpoint)
  }
  
  // Generate routes for each resource
  for (const [resource, resourceEndpoints] of resourceMap) {
    const operations: ('create' | 'read' | 'update' | 'delete')[] = []
    
    // Determine operations from endpoints
    for (const endpoint of resourceEndpoints) {
      const method = typeof endpoint === 'object' ? endpoint.method : 'GET'
      
      if (method === 'GET') operations.push('read')
      if (method === 'POST') operations.push('create')
      if (method === 'PUT' || method === 'PATCH') operations.push('update')
      if (method === 'DELETE') operations.push('delete')
    }
    
    // Remove duplicates
    const uniqueOperations = [...new Set(operations)]
    
    const code = generateCRUDRoute({
      entity: resource,
      table: resource,
      authentication: true,
      operations: uniqueOperations
    })
    
    routes.push({
      path: `/api/${resource}`,
      filename: `app/api/${resource}/route.ts`,
      code
    })
  }
  
  return routes
}

/**
 * Generate database functions
 */
async function generateDatabaseFunctions(architecture: Agent2Output) {
  const functions: Agent3Output['database_functions'] = []
  
  // Always add update_updated_at function
  functions.push({
    name: 'update_updated_at',
    sql: `CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';`,
    description: 'Automatically update updated_at timestamp'
  })
  
  // Add search function if needed
  const tables = architecture.database_schema?.tables || []
  if (tables.length > 0) {
    functions.push({
      name: 'search_records',
      sql: `CREATE OR REPLACE FUNCTION search_records(
  search_table TEXT,
  search_query TEXT
)
RETURNS SETOF JSON AS $$
BEGIN
  RETURN QUERY EXECUTE format(
    'SELECT row_to_json(t) FROM %I t WHERE to_tsvector(t::text) @@ plainto_tsquery($1)',
    search_table
  ) USING search_query;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;`,
      description: 'Full-text search across any table'
    })
  }
  
  return functions
}

/**
 * Generate RLS policies
 */
async function generateRLSPolicies(architecture: Agent2Output) {
  const policies: Agent3Output['rls_policies'] = []
  
  const tables = architecture.database_schema?.tables || []
  
  for (const table of tables) {
    const tableName = typeof table === 'string' ? table : table.name
    
    // Policy 1: Users can view all records (can be customized later)
    policies.push({
      table: tableName,
      policy_name: `${tableName}_select_policy`,
      sql: `CREATE POLICY "${tableName}_select_policy" 
  ON ${tableName} FOR SELECT 
  USING (true);`
    })
    
    // Policy 2: Authenticated users can insert
    policies.push({
      table: tableName,
      policy_name: `${tableName}_insert_policy`,
      sql: `CREATE POLICY "${tableName}_insert_policy" 
  ON ${tableName} FOR INSERT 
  WITH CHECK (auth.role() = 'authenticated');`
    })
    
    // Policy 3: Users can update their own records (if user_id exists)
    policies.push({
      table: tableName,
      policy_name: `${tableName}_update_policy`,
      sql: `CREATE POLICY "${tableName}_update_policy" 
  ON ${tableName} FOR UPDATE 
  USING (
    auth.role() = 'authenticated' AND 
    (user_id = auth.uid() OR auth.role() = 'service_role')
  );`
    })
    
    // Policy 4: Users can delete their own records
    policies.push({
      table: tableName,
      policy_name: `${tableName}_delete_policy`,
      sql: `CREATE POLICY "${tableName}_delete_policy" 
  ON ${tableName} FOR DELETE 
  USING (
    auth.role() = 'authenticated' AND 
    (user_id = auth.uid() OR auth.role() = 'service_role')
  );`
    })
  }
  
  return policies
}

/**
 * Generate validation schemas
 */
async function generateValidationSchemas(architecture: Agent2Output) {
  const schemas: Agent3Output['validation_schemas'] = []
  
  const tables = architecture.database_schema?.tables || []
  
  for (const table of tables) {
    const tableName = typeof table === 'string' ? table : table.name
    const schemaName = tableName.charAt(0).toUpperCase() + tableName.slice(1) + 'Schema'
    
    const schema: Record<string, any> = {
      id: { type: 'string', format: 'uuid', required: false },
      created_at: { type: 'string', format: 'date-time', required: false },
      updated_at: { type: 'string', format: 'date-time', required: false }
    }
    
    // Add custom columns if available
    if (typeof table === 'object' && table.columns) {
      for (const column of table.columns) {
        schema[column.name] = {
          type: column.type.includes('int') ? 'number' : 
                column.type.includes('bool') ? 'boolean' : 'string',
          required: !column.nullable
        }
      }
    }
    
    schemas.push({
      name: schemaName,
      schema
    })
  }
  
  return schemas
}

/**
 * Helper: Generate CRUD API route code
 */
export function generateCRUDRoute(options: {
  entity: string
  table: string
  authentication: boolean
  operations: ('create' | 'read' | 'update' | 'delete')[]
}): string {
  const { entity, table, authentication, operations } = options
  
  let code = `import { NextRequest, NextResponse } from 'next/server'
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs'
import { cookies } from 'next/headers'

`
  
  // GET (Read)
  if (operations.includes('read')) {
    code += `export async function GET(request: NextRequest) {
  const supabase = createRouteHandlerClient({ cookies })
  
  ${authentication ? `
  const { data: { session } } = await supabase.auth.getSession()
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }
  ` : ''}
  
  const { data, error } = await supabase
    .from('${table}')
    .select('*')
    .order('created_at', { ascending: false })
  
  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
  
  return NextResponse.json({ data })
}

`
  }
  
  // POST (Create)
  if (operations.includes('create')) {
    code += `export async function POST(request: NextRequest) {
  const supabase = createRouteHandlerClient({ cookies })
  
  ${authentication ? `
  const { data: { session } } = await supabase.auth.getSession()
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }
  ` : ''}
  
  const body = await request.json()
  
  // Add user_id if authenticated
  ${authentication ? `
  const dataToInsert = {
    ...body,
    user_id: session.user.id
  }
  ` : 'const dataToInsert = body'}
  
  const { data, error } = await supabase
    .from('${table}')
    .insert(dataToInsert)
    .select()
  
  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
  
  return NextResponse.json({ data }, { status: 201 })
}

`
  }
  
  // PUT (Update)
  if (operations.includes('update')) {
    code += `export async function PUT(request: NextRequest) {
  const supabase = createRouteHandlerClient({ cookies })
  
  ${authentication ? `
  const { data: { session } } = await supabase.auth.getSession()
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }
  ` : ''}
  
  const body = await request.json()
  const { id, ...updates } = body
  
  if (!id) {
    return NextResponse.json({ error: 'ID is required' }, { status: 400 })
  }
  
  const { data, error } = await supabase
    .from('${table}')
    .update(updates)
    .eq('id', id)
    ${authentication ? `.eq('user_id', session.user.id)` : ''}
    .select()
  
  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
  
  if (!data || data.length === 0) {
    return NextResponse.json({ error: 'Record not found or unauthorized' }, { status: 404 })
  }
  
  return NextResponse.json({ data })
}

`
  }
  
  // DELETE
  if (operations.includes('delete')) {
    code += `export async function DELETE(request: NextRequest) {
  const supabase = createRouteHandlerClient({ cookies })
  
  ${authentication ? `
  const { data: { session } } = await supabase.auth.getSession()
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }
  ` : ''}
  
  const { searchParams } = new URL(request.url)
  const id = searchParams.get('id')
  
  if (!id) {
    return NextResponse.json({ error: 'ID is required' }, { status: 400 })
  }
  
  const { error } = await supabase
    .from('${table}')
    .delete()
    .eq('id', id)
    ${authentication ? `.eq('user_id', session.user.id)` : ''}
  
  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
  
  return NextResponse.json({ success: true })
}
`
  }
  
  return code
}
